#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba16f, set = 0, binding = 0) uniform image2D image;

layout (push_constant) uniform constants
{
    int particle_count;
    float smoothing_radius;
} pc;

layout(std140, set = 0, binding = 1) buffer ParticleBuffer
{
    vec4 positions[];
};

const float particle_mass = 1.0;

const float pi = 3.14159265359;
const float FLOAT_MAX = 1.0 / 0.0;

ivec2 image_size;

float smoothing_kernel_spiky(vec2 position, float radius)
{
    float dst_squared = position.x * position.x + position.y * position.y;

    if (radius * radius > dst_squared)
    {
        float volume = (pi * pow(radius, 4)) / 6;
        return (radius - sqrt(dst_squared)) * (radius - sqrt(dst_squared)) / volume;
    }
    return 0.0;
}

float poly6_scaling_factor = 4.0 / (pi * pow(pc.smoothing_radius, 8));

float smoothing_kernel_poly6(vec2 position, float radius)
{
    float dst_squared = position.x * position.x + position.y * position.y;

    if (radius * radius > dst_squared)
    {
        float value = radius * radius - dst_squared;
        // float volume = pi * pow(radius, 8) / 4;

        return value * value * value * poly6_scaling_factor;
    }
    return 0.0;
}

float smoothing_kernel_poly6_derivative(vec2 position, float radius)
{
    float dst_squared = position.x * position.x + position.y * position.y;

    if (dst_squared < radius * radius)
    {
        float f = radius * radius - dst_squared;
        float scale = -24.0 / (pi * pow(radius, 8));
        return scale * sqrt(dst_squared) * f * f;
    }
    return 0;
}

vec2 calculate_gradient(vec2 point)
{
    vec2 property_gradient = vec2(0);

    for (int i = 0; i < pc.particle_count; ++i)
    {
        vec2 particle_position = vec2(positions[i].x, positions[i].y);
        float particle_property = cos(positions[i].y - 3 + sin(positions[i].x));
        vec2 dir = normalize(particle_position - point);
        float slope = smoothing_kernel_poly6_derivative(particle_position, pc.smoothing_radius);
    
        property_gradient += -particle_property * dir * slope / positions[i].z;
    }

    return property_gradient;
}

float calculate_property(vec2 point)
{
    float property = 0.0;
    
    for(int i = 0; i < pc.particle_count; i++)
    {
        float particle_property = cos(positions[i].y - 3 + sin(positions[i].x));

        float influense = smoothing_kernel_poly6(vec2(positions[i].x, positions[i].y) - point, pc.smoothing_radius);

        property += influense * particle_property / positions[i].z;
    }

    return property;
}

void main()
{
    ivec2 texel_coord = ivec2(gl_GlobalInvocationID.xy);
    image_size = imageSize(image);

    vec2 position = vec2(float(texel_coord.x) / float(image_size.x), float(texel_coord.y) / float(image_size.y));

    if (texel_coord.x < image_size.x && texel_coord.y < image_size.y)
    {
        // float property = calculate_property(position);

        vec2 property_gradient = calculate_gradient(position);
        imageStore(image, texel_coord, vec4(property_gradient, 0, 1.0));

        // imageStore(image, texel_coord, property * vec4(1.0)); 
        // imageStore(image, texel_coord, (density + 100.0) / 900.0 * vec4(1.0, 1.0, 1.0, 1.0));
    }
}
